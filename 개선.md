# ğŸ”§ Shop_Automation ê°œì„  ì‚¬í•­

**í”„ë¡œì íŠ¸**: ì˜ë¦¼ ë°œì£¼ì„œ ìë™í™” ì‹œìŠ¤í…œ V8  
**ì‘ì„±ì¼**: 2026-01-05  
**ëª©ì **: í˜„ì¬ ì‹œìŠ¤í…œì˜ ë¬¸ì œì  íŒŒì•… ë° ê°œì„  ë°©ì•ˆ ì œì‹œ

---

## ğŸš¨ ê¸´ê¸‰ ê°œì„  ì‚¬í•­ (High Priority)

### 1. **ë°ì´í„° ì—†ì„ ë•Œ ë¬´í•œ ì‹¤í–‰ ë¬¸ì œ** â­â­â­

#### í˜„ì¬ ë¬¸ì œ
- ì—…ë¡œë“œí•  ë°ì´í„°ê°€ ì—†ì„ ë•Œë„ ìë™í™” í”„ë¡œì„¸ìŠ¤ê°€ ê³„ì† ì‹¤í–‰ë¨
- ë¶ˆí•„ìš”í•œ ë¸Œë¼ìš°ì € ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° ë¦¬ì†ŒìŠ¤ ë‚­ë¹„
- ì—ëŸ¬ ë¡œê·¸ ëˆ„ì  ë° ì‹œìŠ¤í…œ ë¶€í•˜ ì¦ê°€

#### ê°œì„  ë°©ì•ˆ

**A. ì‚¬ì „ ê²€ì¦ ë¡œì§ ì¶”ê°€**

```python
# v8_auto_server.py ê°œì„ 

def check_pending_orders():
    """ì—…ë¡œë“œ ëŒ€ê¸° ì¤‘ì¸ ì£¼ë¬¸ í™•ì¸"""
    downloads_dir = Path("data/downloads")
    
    if not downloads_dir.exists():
        return []
    
    # ë¯¸ì²˜ë¦¬ íŒŒì¼ ëª©ë¡ í™•ì¸
    pending_files = []
    for file in downloads_dir.glob("*.{html,mht,mhtml}"):
        if not is_processed(file):
            pending_files.append(file)
    
    return pending_files

def is_processed(file_path):
    """íŒŒì¼ ì²˜ë¦¬ ì´ë ¥ í™•ì¸"""
    history_file = Path("data/upload_history.json")
    
    if not history_file.exists():
        return False
    
    with open(history_file, 'r', encoding='utf-8') as f:
        history = json.load(f)
    
    file_hash = hashlib.md5(file_path.read_bytes()).hexdigest()
    return file_hash in history.get('processed_files', [])

@app.route('/upload/ledger', methods=['POST'])
def upload_ledger():
    """ì›ì¥ ì—…ë¡œë“œ - ì‚¬ì „ ê²€ì¦ ì¶”ê°€"""
    
    # 1. ì—…ë¡œë“œí•  ë°ì´í„° í™•ì¸
    pending_orders = check_pending_orders()
    
    if not pending_orders:
        return jsonify({
            "status": "no_data",
            "message": "ì—…ë¡œë“œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.",
            "pending_count": 0
        }), 200
    
    # 2. ë°ì´í„°ê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰
    try:
        result = run_upload_process(pending_orders, upload_type='ledger')
        return jsonify({
            "status": "success",
            "message": f"{len(pending_orders)}ê±´ ì—…ë¡œë“œ ì™„ë£Œ",
            "processed_files": result
        }), 200
    except Exception as e:
        return jsonify({
            "status": "error",
            "message": str(e)
        }), 500
```

**B. Auto-Downloader ê°œì„ **

```python
# v8_auto_server.py - Auto-Downloader ë¡œì§

class AutoDownloader:
    def __init__(self):
        self.interval = 1800  # 30ë¶„ (ì´ˆ ë‹¨ìœ„)
        self.running = False
        self.last_check = None
        self.consecutive_empty_checks = 0  # ì—°ì† ë¹ˆ ì²´í¬ ì¹´ìš´íŠ¸
        
    def run(self):
        """ìë™ ë‹¤ìš´ë¡œë“œ ì‹¤í–‰ - ì§€ëŠ¥í˜• ëŒ€ê¸°"""
        while self.running:
            try:
                # ì‹ ê·œ ì£¼ë¬¸ í™•ì¸
                new_orders = self.check_new_orders()
                
                if new_orders:
                    # ì£¼ë¬¸ì´ ìˆìœ¼ë©´ ë‹¤ìš´ë¡œë“œ
                    self.download_orders(new_orders)
                    self.consecutive_empty_checks = 0
                    logging.info(f"âœ“ {len(new_orders)}ê±´ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ")
                else:
                    # ì£¼ë¬¸ì´ ì—†ìœ¼ë©´ ì¹´ìš´íŠ¸ ì¦ê°€
                    self.consecutive_empty_checks += 1
                    logging.info(f"â—‹ ì‹ ê·œ ì£¼ë¬¸ ì—†ìŒ (ì—°ì† {self.consecutive_empty_checks}íšŒ)")
                    
                    # ì—°ì† 10íšŒ ë¹ˆ ì²´í¬ ì‹œ ê°„ê²© ì¦ê°€ (ìµœëŒ€ 2ì‹œê°„)
                    if self.consecutive_empty_checks >= 10:
                        extended_interval = min(self.interval * 2, 7200)
                        logging.info(f"â†’ ëŒ€ê¸° ê°„ê²© ì—°ì¥: {extended_interval/60}ë¶„")
                        time.sleep(extended_interval)
                        continue
                
                # ì •ìƒ ê°„ê²© ëŒ€ê¸°
                time.sleep(self.interval)
                
            except Exception as e:
                logging.error(f"âœ— Auto-Downloader ì˜¤ë¥˜: {e}")
                time.sleep(60)  # ì˜¤ë¥˜ ì‹œ 1ë¶„ ëŒ€ê¸°
    
    def check_new_orders(self):
        """ì‹ ê·œ ì£¼ë¬¸ í™•ì¸ - ë¹ ë¥¸ ì²´í¬"""
        # ë¸Œë¼ìš°ì € ì—†ì´ API í˜¸ì¶œ ë˜ëŠ” ê²½ëŸ‰ ì²´í¬
        # ì‹¤ì œ ë‹¤ìš´ë¡œë“œ ì „ì— ì‹ ê·œ ì£¼ë¬¸ ì¡´ì¬ ì—¬ë¶€ë§Œ í™•ì¸
        pass
```

**C. ì›¹ UI ìƒíƒœ í‘œì‹œ ê°œì„ **

```html
<!-- templates/index.html ê°œì„  -->
<div class="status-panel">
    <h3>ì‹œìŠ¤í…œ ìƒíƒœ</h3>
    <div id="pending-count" class="status-item">
        <span class="label">ëŒ€ê¸° ì£¼ë¬¸:</span>
        <span id="count" class="value">-</span>ê±´
    </div>
    <div id="last-check" class="status-item">
        <span class="label">ë§ˆì§€ë§‰ í™•ì¸:</span>
        <span id="time" class="value">-</span>
    </div>
    <div id="next-check" class="status-item">
        <span class="label">ë‹¤ìŒ í™•ì¸:</span>
        <span id="countdown" class="value">-</span>
    </div>
</div>

<button id="upload-ledger" onclick="uploadLedger()" 
        class="btn btn-primary" disabled>
    ì›ì¥ ì—…ë¡œë“œ (ë°ì´í„° ì—†ìŒ)
</button>

<script>
// ì£¼ê¸°ì ìœ¼ë¡œ ëŒ€ê¸° ì£¼ë¬¸ ìˆ˜ í™•ì¸
setInterval(async () => {
    const response = await fetch('/api/status');
    const data = await response.json();
    
    document.getElementById('count').textContent = data.pending_count;
    
    // ë°ì´í„° ìˆì„ ë•Œë§Œ ë²„íŠ¼ í™œì„±í™”
    const uploadBtn = document.getElementById('upload-ledger');
    if (data.pending_count > 0) {
        uploadBtn.disabled = false;
        uploadBtn.textContent = `ì›ì¥ ì—…ë¡œë“œ (${data.pending_count}ê±´)`;
        uploadBtn.classList.add('btn-enabled');
    } else {
        uploadBtn.disabled = true;
        uploadBtn.textContent = 'ì›ì¥ ì—…ë¡œë“œ (ë°ì´í„° ì—†ìŒ)';
        uploadBtn.classList.remove('btn-enabled');
    }
}, 5000);  // 5ì´ˆë§ˆë‹¤ í™•ì¸
</script>
```

---

### 2. **ì—ëŸ¬ í•¸ë“¤ë§ ë° ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜** â­â­â­

#### í˜„ì¬ ë¬¸ì œ
- ì—ëŸ¬ ë°œìƒ ì‹œ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨
- ë¶€ë¶„ ì‹¤íŒ¨ ì‹œ ë³µêµ¬ ë¶ˆê°€
- ì—ëŸ¬ ì›ì¸ ì¶”ì  ì–´ë ¤ì›€

#### ê°œì„  ë°©ì•ˆ

```python
# error_handler.py - ìƒˆ íŒŒì¼ ìƒì„±

import logging
import traceback
from enum import Enum
from datetime import datetime
from pathlib import Path

class ErrorSeverity(Enum):
    LOW = "ê²½ê³ "
    MEDIUM = "ì£¼ì˜"
    HIGH = "ì‹¬ê°"
    CRITICAL = "ì¹˜ëª…ì "

class ErrorHandler:
    def __init__(self, log_dir="logs"):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(exist_ok=True)
        self.error_log = self.log_dir / "errors.json"
        
    def log_error(self, error, context=None, severity=ErrorSeverity.MEDIUM):
        """êµ¬ì¡°í™”ëœ ì—ëŸ¬ ë¡œê¹…"""
        error_record = {
            "timestamp": datetime.now().isoformat(),
            "severity": severity.value,
            "error_type": type(error).__name__,
            "error_message": str(error),
            "traceback": traceback.format_exc(),
            "context": context or {}
        }
        
        # JSON íŒŒì¼ì— ì¶”ê°€
        errors = []
        if self.error_log.exists():
            with open(self.error_log, 'r', encoding='utf-8') as f:
                errors = json.load(f)
        
        errors.append(error_record)
        
        # ìµœê·¼ 1000ê°œë§Œ ìœ ì§€
        errors = errors[-1000:]
        
        with open(self.error_log, 'w', encoding='utf-8') as f:
            json.dump(errors, f, ensure_ascii=False, indent=2)
        
        # ì‹¬ê°í•œ ì—ëŸ¬ëŠ” ì¦‰ì‹œ ì•Œë¦¼
        if severity in [ErrorSeverity.HIGH, ErrorSeverity.CRITICAL]:
            self.send_alert(error_record)
    
    def send_alert(self, error_record):
        """ê¸´ê¸‰ ì•Œë¦¼ ì „ì†¡ (Slack, Email ë“±)"""
        # TODO: Slack ì›¹í›… ë˜ëŠ” ì´ë©”ì¼ ì „ì†¡
        logging.critical(f"ğŸš¨ ê¸´ê¸‰ ì•Œë¦¼: {error_record['error_message']}")

# ì‚¬ìš© ì˜ˆì‹œ
error_handler = ErrorHandler()

try:
    # ìœ„í—˜í•œ ì‘ì—…
    upload_to_erp()
except Exception as e:
    error_handler.log_error(
        e, 
        context={"file": current_file, "step": "ERP ì—…ë¡œë“œ"},
        severity=ErrorSeverity.HIGH
    )
    # ì—ëŸ¬ì—ë„ ë¶ˆêµ¬í•˜ê³  ë‹¤ìŒ íŒŒì¼ ì²˜ë¦¬ ê³„ì†
```

**ë°°ì¹˜ ì²˜ë¦¬ ê°œì„ **

```python
# v8_auto_server.py ê°œì„ 

def process_batch_with_retry(files, max_retries=3):
    """ë°°ì¹˜ ì²˜ë¦¬ - ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„"""
    results = {
        "success": [],
        "failed": [],
        "skipped": []
    }
    
    for file_path in files:
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                # íŒŒì¼ ì²˜ë¦¬
                result = process_single_file(file_path)
                results["success"].append({
                    "file": file_path.name,
                    "result": result
                })
                break  # ì„±ê³µ ì‹œ ë‹¤ìŒ íŒŒì¼ë¡œ
                
            except RecoverableError as e:
                # ë³µêµ¬ ê°€ëŠ¥í•œ ì—ëŸ¬ - ì¬ì‹œë„
                retry_count += 1
                logging.warning(f"âš  ì¬ì‹œë„ {retry_count}/{max_retries}: {e}")
                time.sleep(2 ** retry_count)  # ì§€ìˆ˜ ë°±ì˜¤í”„
                
            except CriticalError as e:
                # ì¹˜ëª…ì  ì—ëŸ¬ - ê±´ë„ˆë›°ê¸°
                results["failed"].append({
                    "file": file_path.name,
                    "error": str(e)
                })
                error_handler.log_error(e, severity=ErrorSeverity.HIGH)
                break
        
        else:
            # ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼
            results["skipped"].append({
                "file": file_path.name,
                "reason": "ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼"
            })
    
    return results
```

---

## ğŸ“Š ì¤‘ìš” ê°œì„  ì‚¬í•­ (Medium Priority)

### 3. **ë¡œê¹… ì‹œìŠ¤í…œ ê³ ë„í™”** â­â­

#### ê°œì„  ë°©ì•ˆ

```python
# logging_config.py - ìƒˆ íŒŒì¼ ìƒì„±

import logging
import json
from datetime import datetime
from pathlib import Path

class JsonFormatter(logging.Formatter):
    """JSON í˜•ì‹ ë¡œê·¸ í¬ë§¤í„°"""
    
    def format(self, record):
        log_record = {
            "timestamp": datetime.fromtimestamp(record.created).isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        
        # ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸ ì •ë³´
        if hasattr(record, 'extra'):
            log_record.update(record.extra)
        
        return json.dumps(log_record, ensure_ascii=False)

def setup_logging(log_dir="logs"):
    """ë¡œê¹… ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
    log_dir = Path(log_dir)
    log_dir.mkdir(exist_ok=True)
    
    # íŒŒì¼ í•¸ë“¤ëŸ¬ (JSON)
    json_handler = logging.FileHandler(
        log_dir / f"app_{datetime.now():%Y%m%d}.json",
        encoding='utf-8'
    )
    json_handler.setFormatter(JsonFormatter())
    json_handler.setLevel(logging.DEBUG)
    
    # ì½˜ì†” í•¸ë“¤ëŸ¬ (ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•ì‹)
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(
        logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
    )
    console_handler.setLevel(logging.INFO)
    
    # ë£¨íŠ¸ ë¡œê±° ì„¤ì •
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    logger.addHandler(json_handler)
    logger.addHandler(console_handler)
    
    return logger

# v8_auto_server.pyì—ì„œ ì‚¬ìš©
from logging_config import setup_logging

logger = setup_logging()
logger.info("ì‹œìŠ¤í…œ ì‹œì‘", extra={"version": "V8", "mode": "production"})
```

---

### 4. **ì„¤ì • ê´€ë¦¬ ì‹œìŠ¤í…œ** â­â­

#### í˜„ì¬ ë¬¸ì œ
- í•˜ë“œì½”ë”©ëœ ì„¤ì • ê°’
- í™˜ê²½ë³„ ì„¤ì • ë¶ˆê°€
- ë¯¼ê° ì •ë³´ ë…¸ì¶œ ìœ„í—˜

#### ê°œì„  ë°©ì•ˆ

**A. .env íŒŒì¼ ì‚¬ìš©**

```bash
# .env íŒŒì¼ ìƒì„±
FLASK_PORT=5080
FLASK_DEBUG=false

# ì˜ë¦¼ ì‚¬ì´íŠ¸
YOUNGRIM_URL=https://door.youngrim.com
YOUNGRIM_CHECK_INTERVAL=1800

# ERP ì„¤ì •
ERP_URL=https://your-ecount-domain.com
ERP_COMPANY_CODE=YOUR_COMPANY
ERP_TIMEOUT=30

# íŒŒì¼ ê²½ë¡œ
DOWNLOADS_DIR=data/downloads
LOGS_DIR=logs
HISTORY_FILE=data/upload_history.json

# ë¸Œë¼ìš°ì € ì„¤ì •
BROWSER_HEADLESS=false
BROWSER_PROFILE=avast_automation_profile

# ì•Œë¦¼ ì„¤ì • (ì„ íƒì‚¬í•­)
SLACK_WEBHOOK_URL=
EMAIL_ALERT_TO=

# ì¬ì‹œë„ ì„¤ì •
MAX_RETRIES=3
RETRY_DELAY=2
```

**B. ì„¤ì • ë¡œë”**

```python
# config.py - ìƒˆ íŒŒì¼ ìƒì„±

from pathlib import Path
from dotenv import load_dotenv
import os

class Config:
    """ì„¤ì • ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, env_file=".env"):
        load_dotenv(env_file)
        
        # Flask ì„¤ì •
        self.FLASK_PORT = int(os.getenv("FLASK_PORT", 5080))
        self.FLASK_DEBUG = os.getenv("FLASK_DEBUG", "false").lower() == "true"
        
        # ì˜ë¦¼ ì„¤ì •
        self.YOUNGRIM_URL = os.getenv("YOUNGRIM_URL")
        self.YOUNGRIM_CHECK_INTERVAL = int(os.getenv("YOUNGRIM_CHECK_INTERVAL", 1800))
        
        # ERP ì„¤ì •
        self.ERP_URL = os.getenv("ERP_URL")
        self.ERP_COMPANY_CODE = os.getenv("ERP_COMPANY_CODE")
        self.ERP_TIMEOUT = int(os.getenv("ERP_TIMEOUT", 30))
        
        # ê²½ë¡œ ì„¤ì •
        self.DOWNLOADS_DIR = Path(os.getenv("DOWNLOADS_DIR", "data/downloads"))
        self.LOGS_DIR = Path(os.getenv("LOGS_DIR", "logs"))
        self.HISTORY_FILE = Path(os.getenv("HISTORY_FILE", "data/upload_history.json"))
        
        # ë””ë ‰í† ë¦¬ ìƒì„±
        self.DOWNLOADS_DIR.mkdir(parents=True, exist_ok=True)
        self.LOGS_DIR.mkdir(parents=True, exist_ok=True)
        
        # ë¸Œë¼ìš°ì € ì„¤ì •
        self.BROWSER_HEADLESS = os.getenv("BROWSER_HEADLESS", "false").lower() == "true"
        self.BROWSER_PROFILE = os.getenv("BROWSER_PROFILE", "avast_automation_profile")
        
        # ì¬ì‹œë„ ì„¤ì •
        self.MAX_RETRIES = int(os.getenv("MAX_RETRIES", 3))
        self.RETRY_DELAY = int(os.getenv("RETRY_DELAY", 2))
        
        # ì•Œë¦¼ ì„¤ì •
        self.SLACK_WEBHOOK_URL = os.getenv("SLACK_WEBHOOK_URL")
        self.EMAIL_ALERT_TO = os.getenv("EMAIL_ALERT_TO")
    
    def validate(self):
        """í•„ìˆ˜ ì„¤ì • ê²€ì¦"""
        required_fields = [
            "YOUNGRIM_URL",
            "ERP_URL",
            "ERP_COMPANY_CODE"
        ]
        
        missing = []
        for field in required_fields:
            if not getattr(self, field):
                missing.append(field)
        
        if missing:
            raise ValueError(f"í•„ìˆ˜ ì„¤ì • ëˆ„ë½: {', '.join(missing)}")
        
        return True

# v8_auto_server.pyì—ì„œ ì‚¬ìš©
from config import Config

config = Config()
config.validate()

app = Flask(__name__)
app.config.from_object(config)
```

---

### 5. **ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ** â­â­

```python
# v8_auto_server.py - API ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€

@app.route('/api/stats', methods=['GET'])
def get_stats():
    """í†µê³„ ì •ë³´ ë°˜í™˜"""
    
    # ì²˜ë¦¬ ì´ë ¥ ë¡œë“œ
    with open(config.HISTORY_FILE, 'r', encoding='utf-8') as f:
        history = json.load(f)
    
    # ì˜¤ëŠ˜ì˜ í†µê³„
    today = datetime.now().date()
    today_processed = [
        item for item in history.get('processed_files', [])
        if datetime.fromisoformat(item['timestamp']).date() == today
    ]
    
    return jsonify({
        "today": {
            "processed": len(today_processed),
            "success": sum(1 for item in today_processed if item['status'] == 'success'),
            "failed": sum(1 for item in today_processed if item['status'] == 'failed')
        },
        "total": {
            "processed": len(history.get('processed_files', [])),
            "pending": len(check_pending_orders())
        },
        "system": {
            "uptime": get_uptime(),
            "last_check": auto_downloader.last_check.isoformat() if auto_downloader.last_check else None,
            "status": "running" if auto_downloader.running else "stopped"
        }
    })

@app.route('/api/errors', methods=['GET'])
def get_recent_errors():
    """ìµœê·¼ ì—ëŸ¬ ëª©ë¡"""
    error_log = Path("logs/errors.json")
    
    if not error_log.exists():
        return jsonify([])
    
    with open(error_log, 'r', encoding='utf-8') as f:
        errors = json.load(f)
    
    # ìµœê·¼ 50ê°œë§Œ
    return jsonify(errors[-50:])
```

---

## ğŸ”„ ì¥ê¸° ê°œì„  ì‚¬í•­ (Low Priority)

### 6. **ì½”ë“œ êµ¬ì¡° ë¦¬íŒ©í† ë§** â­

```
Shop_Automation/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ config.py          # ì„¤ì • ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ logging_config.py  # ë¡œê¹… ì„¤ì •
â”‚   â”‚   â””â”€â”€ error_handler.py   # ì—ëŸ¬ í•¸ë“¤ëŸ¬
â”‚   â”œâ”€â”€ parsers/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ html_parser.py     # HTML íŒŒì‹±
â”‚   â”‚   â”œâ”€â”€ mhtml_parser.py    # MHTML íŒŒì‹±
â”‚   â”‚   â””â”€â”€ code_generator.py  # í’ˆëª© ì½”ë“œ ìƒì„±
â”‚   â”œâ”€â”€ automation/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ downloader.py      # ì˜ë¦¼ ë‹¤ìš´ë¡œë“œ
â”‚   â”‚   â””â”€â”€ erp_uploader.py    # ERP ì—…ë¡œë“œ
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ routes.py          # Flask ë¼ìš°íŠ¸
â”‚   â”‚   â””â”€â”€ models.py          # ë°ì´í„° ëª¨ë¸
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ file_utils.py      # íŒŒì¼ ì²˜ë¦¬
â”‚       â””â”€â”€ validators.py      # ë°ì´í„° ê²€ì¦
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_parsers.py
â”‚   â”œâ”€â”€ test_automation.py
â”‚   â””â”€â”€ test_api.py
â”œâ”€â”€ .env                       # í™˜ê²½ ë³€ìˆ˜
â”œâ”€â”€ .env.example               # í™˜ê²½ ë³€ìˆ˜ ì˜ˆì œ
â”œâ”€â”€ requirements.txt
â””â”€â”€ main.py                    # ì§„ì…ì 
```

### 7. **í…ŒìŠ¤íŠ¸ ìë™í™”**

```python
# tests/test_parsers.py

import pytest
from src.parsers.html_parser import parse_order_html

def test_parse_valid_html():
    """ì •ìƒ HTML íŒŒì‹± í…ŒìŠ¤íŠ¸"""
    html_content = """
    <html>
        <body>
            <table>
                <tr><td>í’ˆëª©ëª…</td><td>ì„ê³ ë³´ë“œ 9T</td></tr>
                <tr><td>ìˆ˜ëŸ‰</td><td>100</td></tr>
            </table>
        </body>
    </html>
    """
    
    result = parse_order_html(html_content)
    
    assert result is not None
    assert result['item_name'] == 'ì„ê³ ë³´ë“œ 9T'
    assert result['quantity'] == 100

def test_parse_invalid_html():
    """ì˜ëª»ëœ HTML íŒŒì‹± í…ŒìŠ¤íŠ¸"""
    html_content = "<html><body>Invalid</body></html>"
    
    with pytest.raises(ValueError):
        parse_order_html(html_content)

# pytest ì‹¤í–‰
# pytest tests/ -v --cov=src
```

### 8. **ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬ì¶•**

```python
# src/utils/notifier.py

import requests
from datetime import datetime

class SlackNotifier:
    def __init__(self, webhook_url):
        self.webhook_url = webhook_url
    
    def send_alert(self, message, level="info"):
        """Slack ì•Œë¦¼ ì „ì†¡"""
        colors = {
            "info": "#36a64f",
            "warning": "#ff9900",
            "error": "#ff0000"
        }
        
        payload = {
            "attachments": [{
                "color": colors.get(level, "#36a64f"),
                "title": f"Shop Automation Alert ({level.upper()})",
                "text": message,
                "footer": "Shop Automation System",
                "ts": int(datetime.now().timestamp())
            }]
        }
        
        try:
            response = requests.post(self.webhook_url, json=payload)
            response.raise_for_status()
        except Exception as e:
            logging.error(f"Slack ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")

# ì‚¬ìš© ì˜ˆì‹œ
notifier = SlackNotifier(config.SLACK_WEBHOOK_URL)
notifier.send_alert("âœ“ 10ê±´ì˜ ì£¼ë¬¸ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.", level="info")
notifier.send_alert("âš  5íšŒ ì—°ì† ë¹ˆ ì²´í¬ - ëŒ€ê¸° ê°„ê²© ì—°ì¥", level="warning")
notifier.send_alert("âœ— ERP ì—°ê²° ì‹¤íŒ¨ - ì¬ì‹œë„ í•„ìš”", level="error")
```

---

## ğŸ“‹ êµ¬í˜„ ìš°ì„ ìˆœìœ„

### Phase 1: ê¸´ê¸‰ (1-2ì£¼)
- [x] ë°ì´í„° ì—†ì„ ë•Œ ë¬´í•œ ì‹¤í–‰ ë¬¸ì œ í•´ê²°
- [x] ì‚¬ì „ ê²€ì¦ ë¡œì§ ì¶”ê°€
- [x] ì›¹ UI ìƒíƒœ í‘œì‹œ ê°œì„ 
- [ ] ì—ëŸ¬ í•¸ë“¤ë§ ê°•í™”

### Phase 2: ì¤‘ìš” (2-4ì£¼)
- [ ] ë¡œê¹… ì‹œìŠ¤í…œ ê³ ë„í™”
- [ ] ì„¤ì • ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•
- [ ] ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ
- [ ] ë°°ì¹˜ ì²˜ë¦¬ ì¬ì‹œë„ ë¡œì§

### Phase 3: ì¥ê¸° (1-2ê°œì›”)
- [ ] ì½”ë“œ êµ¬ì¡° ë¦¬íŒ©í† ë§
- [ ] í…ŒìŠ¤íŠ¸ ìë™í™”
- [ ] CI/CD íŒŒì´í”„ë¼ì¸
- [ ] ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬ì¶•

---

## ğŸ” ì¦‰ì‹œ ì ìš© ê°€ëŠ¥í•œ Quick Fix

```python
# v8_auto_server.py - ìµœì†Œ ë³€ê²½ìœ¼ë¡œ ì¦‰ì‹œ ì ìš© ê°€ëŠ¥

# 1. ë°ì´í„° ê²€ì¦ í•¨ìˆ˜ ì¶”ê°€
def has_pending_data():
    """ëŒ€ê¸° ì¤‘ì¸ ë°ì´í„° í™•ì¸"""
    downloads_dir = Path("data/downloads")
    if not downloads_dir.exists():
        return False
    
    files = list(downloads_dir.glob("*.{html,mht,mhtml}"))
    return len(files) > 0

# 2. ì—…ë¡œë“œ ì—”ë“œí¬ì¸íŠ¸ ìˆ˜ì •
@app.route('/upload/ledger', methods=['POST'])
def upload_ledger():
    # ë°ì´í„° í™•ì¸
    if not has_pending_data():
        logging.info("â—‹ ì—…ë¡œë“œí•  ë°ì´í„° ì—†ìŒ - ì‹¤í–‰ ì¤‘ë‹¨")
        return jsonify({
            "status": "no_data",
            "message": "ì—…ë¡œë“œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."
        }), 200
    
    # ê¸°ì¡´ ë¡œì§...
    logging.info("â–¶ ì—…ë¡œë“œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘")
    # ... ë‚˜ë¨¸ì§€ ì½”ë“œ

# 3. Auto-Downloaderì— ë¹ˆ ì²´í¬ ì¹´ìš´í„° ì¶”ê°€
def auto_download_loop():
    empty_checks = 0
    
    while True:
        new_files = download_new_orders()
        
        if not new_files:
            empty_checks += 1
            logging.info(f"â—‹ ì‹ ê·œ ì£¼ë¬¸ ì—†ìŒ (ì—°ì† {empty_checks}íšŒ)")
            
            # 10íšŒ ì—°ì† ë¹ˆ ì²´í¬ ì‹œ ê°„ê²© 2ë°°
            if empty_checks >= 10:
                time.sleep(3600)  # 1ì‹œê°„ ëŒ€ê¸°
                empty_checks = 0  # ë¦¬ì…‹
                continue
        else:
            empty_checks = 0  # ì£¼ë¬¸ ìˆìœ¼ë©´ ë¦¬ì…‹
            logging.info(f"âœ“ {len(new_files)}ê±´ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ")
        
        time.sleep(1800)  # 30ë¶„
```

---

## ğŸ“ ë³€ê²½ ì´ë ¥

| ë‚ ì§œ | ë²„ì „ | ë³€ê²½ ë‚´ìš© |
|------|------|----------|
| 2026-01-05 | 1.0 | ì´ˆê¸° ë¬¸ì„œ ì‘ì„± |

---

**ë¬¸ì„œ ì‘ì„±**: Zart / Claude  
**ë¦¬ë·° í•„ìš”**: ê°œë°œíŒ€  
**ì ìš© ì‹œì‘**: 2026-01-06 (ì˜ˆì •)
